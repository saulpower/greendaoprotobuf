package com.saulpower.GreenWireTest.database;

import java.util.List;
import de.greenrobot.dao.DaoEnum;
import java.util.Map;
import java.util.HashMap;

import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table IDENTIFICATION.
 */
public class Identification extends SyncBase  {

    private transient long personPersonId;
    private String externalID;
    private String expiration;
    private String verifiedByID;
    private String guid;
    private String name;
    private String issuedBy;
    private String dateVerified;
    private transient long identificationStudentId;
    private String tagString;
    private String dateIssued;
    private Long tenantID;
    private transient long saveResultSaveResultId;
    private String dateLastModified;
    private String number;
    private transient long identificationGuardianId;
    private transient Long syncBaseId;
    private Boolean isDeleted;
    private Integer version;
    private transient long identificationPersonId;
    private Long id;
    private String dateCreated;
    private IdentificationType type;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient IdentificationDao myDao;
    private Person person;
    private Long person__resolvedKey;
    private SaveResult saveResult;
    private Long saveResult__resolvedKey;
    private List<Attachment> attachments;
    private List<CustomValue> customValues;

    public Identification() {
    }

    public Identification(Long id) {
        this.id = id;
        setDerivedEntityType(getClass().getCanonicalName());
    }

    Identification(long personPersonId, String externalID, String expiration, String verifiedByID, String guid, String name, String issuedBy, String dateVerified, long identificationStudentId, String tagString, String dateIssued, Long tenantID, long saveResultSaveResultId, String dateLastModified, String number, long identificationGuardianId, Long syncBaseId, Boolean isDeleted, Integer version, long identificationPersonId, Long id, String dateCreated, IdentificationType type) {
        this.personPersonId = personPersonId;
        this.externalID = externalID;
        this.expiration = expiration;
        this.verifiedByID = verifiedByID;
        this.guid = guid;
        this.name = name;
        this.issuedBy = issuedBy;
        this.dateVerified = dateVerified;
        this.identificationStudentId = identificationStudentId;
        this.tagString = tagString;
        this.dateIssued = dateIssued;
        this.tenantID = tenantID;
        this.saveResultSaveResultId = saveResultSaveResultId;
        this.dateLastModified = dateLastModified;
        this.number = number;
        this.identificationGuardianId = identificationGuardianId;
        this.syncBaseId = syncBaseId;
        this.isDeleted = isDeleted;
        this.version = version;
        this.identificationPersonId = identificationPersonId;
        this.id = id;
        this.dateCreated = dateCreated;
        this.type = type;
    }

    public Identification(long personPersonId, String externalID, String expiration, String verifiedByID, String guid, String name, String issuedBy, String dateVerified, long identificationStudentId, String tagString, String dateIssued, Long tenantID, long saveResultSaveResultId, String dateLastModified, String number, long identificationGuardianId, Boolean isDeleted, Integer version, long identificationPersonId, Long id, String dateCreated, IdentificationType type) {
        this.personPersonId = personPersonId;
        this.externalID = externalID;
        this.expiration = expiration;
        this.verifiedByID = verifiedByID;
        this.guid = guid;
        this.name = name;
        this.issuedBy = issuedBy;
        this.dateVerified = dateVerified;
        this.identificationStudentId = identificationStudentId;
        this.tagString = tagString;
        this.dateIssued = dateIssued;
        this.tenantID = tenantID;
        this.saveResultSaveResultId = saveResultSaveResultId;
        this.dateLastModified = dateLastModified;
        this.number = number;
        this.identificationGuardianId = identificationGuardianId;
        this.isDeleted = isDeleted;
        this.version = version;
        this.identificationPersonId = identificationPersonId;
        this.id = id;
        this.dateCreated = dateCreated;
        this.type = type;
        setDerivedEntityType(getClass().getCanonicalName());
    }

    /** called by internal mechanisms, do not call yourself. */
    @Override
    public void __setDaoSession(DaoSession daoSession) {
        super.__setDaoSession(daoSession);
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getIdentificationDao() : null;
    }

    public long getPersonPersonId() {
        return personPersonId;
    }

    public void setPersonPersonId(long personPersonId) {
        this.personPersonId = personPersonId;
    }

    public String getExternalID() {
        return externalID;
    }

    public void setExternalID(String externalID) {
        this.externalID = externalID;
    }

    public String getExpiration() {
        return expiration;
    }

    public void setExpiration(String expiration) {
        this.expiration = expiration;
    }

    public String getVerifiedByID() {
        return verifiedByID;
    }

    public void setVerifiedByID(String verifiedByID) {
        this.verifiedByID = verifiedByID;
    }

    public String getGuid() {
        return guid;
    }

    public void setGuid(String guid) {
        this.guid = guid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIssuedBy() {
        return issuedBy;
    }

    public void setIssuedBy(String issuedBy) {
        this.issuedBy = issuedBy;
    }

    public String getDateVerified() {
        return dateVerified;
    }

    public void setDateVerified(String dateVerified) {
        this.dateVerified = dateVerified;
    }

    public long getIdentificationStudentId() {
        return identificationStudentId;
    }

    public void setIdentificationStudentId(long identificationStudentId) {
        this.identificationStudentId = identificationStudentId;
    }

    public String getTagString() {
        return tagString;
    }

    public void setTagString(String tagString) {
        this.tagString = tagString;
    }

    public String getDateIssued() {
        return dateIssued;
    }

    public void setDateIssued(String dateIssued) {
        this.dateIssued = dateIssued;
    }

    public Long getTenantID() {
        return tenantID;
    }

    public void setTenantID(Long tenantID) {
        this.tenantID = tenantID;
    }

    public long getSaveResultSaveResultId() {
        return saveResultSaveResultId;
    }

    public void setSaveResultSaveResultId(long saveResultSaveResultId) {
        this.saveResultSaveResultId = saveResultSaveResultId;
    }

    public String getDateLastModified() {
        return dateLastModified;
    }

    public void setDateLastModified(String dateLastModified) {
        this.dateLastModified = dateLastModified;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    public long getIdentificationGuardianId() {
        return identificationGuardianId;
    }

    public void setIdentificationGuardianId(long identificationGuardianId) {
        this.identificationGuardianId = identificationGuardianId;
    }

    public Long getSyncBaseId() {
        return syncBaseId;
    }

    public void setSyncBaseId(Long syncBaseId) {
        this.syncBaseId = syncBaseId;
    }

    public Boolean getIsDeleted() {
        return isDeleted;
    }

    public void setIsDeleted(Boolean isDeleted) {
        this.isDeleted = isDeleted;
    }

    public Integer getVersion() {
        return version;
    }

    public void setVersion(Integer version) {
        this.version = version;
    }

    public long getIdentificationPersonId() {
        return identificationPersonId;
    }

    public void setIdentificationPersonId(long identificationPersonId) {
        this.identificationPersonId = identificationPersonId;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(String dateCreated) {
        this.dateCreated = dateCreated;
    }

    public IdentificationType getType() {
        return type;
    }

    public void setType(IdentificationType type) {
        this.type = type;
    }

    public enum IdentificationType implements DaoEnum {
        DRIVERLICENSE(0),
        BIRTHCERTIFICATE(1),
        PASSPORT(2),
        MILITARYID(3),
        OTHER(4);

        private static final Map<Long, IdentificationType> intToTypeMap = new HashMap<Long, IdentificationType>();

        static {
            for (IdentificationType type : IdentificationType.values()) {
                intToTypeMap.put(type.value, type);
            }
        }

        public static IdentificationType fromInt(long i) {
            IdentificationType type = intToTypeMap.get(Long.valueOf(i));
            return type;
        }

        private final long value;

        private IdentificationType(long value) {
            this.value = value;
        }

        @Override
        public long getValue() {
            return value;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Person getPerson() {
        long __key = this.personPersonId;
        if (person__resolvedKey == null || !person__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PersonDao targetDao = daoSession.getPersonDao();
            Person personNew = targetDao.load(__key);
            synchronized (this) {
                person = personNew;
            	person__resolvedKey = __key;
            }
        }
        return person;
    }

    public void setPerson(Person person) {
        if (person == null) {
            throw new DaoException("To-one property 'personPersonId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.person = person;
            personPersonId = person.getId();
            person__resolvedKey = personPersonId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public SaveResult getSaveResult() {
        long __key = this.saveResultSaveResultId;
        if (saveResult__resolvedKey == null || !saveResult__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SaveResultDao targetDao = daoSession.getSaveResultDao();
            SaveResult saveResultNew = targetDao.load(__key);
            synchronized (this) {
                saveResult = saveResultNew;
            	saveResult__resolvedKey = __key;
            }
        }
        return saveResult;
    }

    public void setSaveResult(SaveResult saveResult) {
        if (saveResult == null) {
            throw new DaoException("To-one property 'saveResultSaveResultId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.saveResult = saveResult;
            saveResultSaveResultId = saveResult.getId();
            saveResult__resolvedKey = saveResultSaveResultId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Attachment> getAttachments() {
        if (attachments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AttachmentDao targetDao = daoSession.getAttachmentDao();
            List<Attachment> attachmentsNew = targetDao._queryIdentification_Attachments(id);
            synchronized (this) {
                if(attachments == null) {
                    attachments = attachmentsNew;
                }
            }
        }
        return attachments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAttachments() {
        attachments = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<CustomValue> getCustomValues() {
        if (customValues == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CustomValueDao targetDao = daoSession.getCustomValueDao();
            List<CustomValue> customValuesNew = targetDao._queryIdentification_CustomValues(id);
            synchronized (this) {
                if(customValues == null) {
                    customValues = customValuesNew;
                }
            }
        }
        return customValues;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetCustomValues() {
        customValues = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}