package com.saulpower.GreenWireTest.database;

import com.saulpower.GreenWireTest.database.BaseState;
import de.greenrobot.dao.sync.GreenSyncBase;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table SYNC_BASE.
 */
public class SyncBase extends GreenSyncBase  {

    private java.util.Date updatedOn;
    private transient BaseState state;
    private transient Long syncBaseId;
    private String externalId;
    private java.util.Date createdOn;
    private transient String derivedEntityType;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient SyncBaseDao myDao;

    public SyncBase() {
    }

    public SyncBase(Long syncBaseId) {
        this.syncBaseId = syncBaseId;
    }

    public SyncBase(java.util.Date updatedOn, BaseState state, Long syncBaseId, String externalId, java.util.Date createdOn, String derivedEntityType) {
        this.updatedOn = updatedOn;
        this.state = state;
        this.syncBaseId = syncBaseId;
        this.externalId = externalId;
        this.createdOn = createdOn;
        this.derivedEntityType = derivedEntityType;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getSyncBaseDao() : null;
    }

    void loadBase(SyncBaseDao dao, Long syncBaseId) {
        myDao = dao;
        this.syncBaseId = syncBaseId;
        myDao.refresh(this);
    }

    void insertBase(SyncBaseDao dao) {
        myDao = dao;
        setState(BaseState.CREATE);
        dao.insert(this);
    }

    void updateBase(SyncBaseDao dao) {
        if (state == BaseState.CREATE) return;
        myDao = dao;
        setState(BaseState.UPDATE);
        myDao.update(this);
    }

    void deleteBase(SyncBaseDao dao) {
        myDao = dao;
        setState(BaseState.DELETE);
        myDao.delete(this);
    }

    @Override
    public void clean() {
        setState(BaseState.CLEAN);
    }
    public java.util.Date getUpdatedOn() {
        return updatedOn;
    }

    public void setUpdatedOn(java.util.Date updatedOn) {
        this.updatedOn = updatedOn;
    }

    public BaseState getState() {
        return state;
    }

    public void setState(BaseState state) {
        this.state = state;
    }

    public Long getSyncBaseId() {
        return syncBaseId;
    }

    public void setSyncBaseId(Long syncBaseId) {
        this.syncBaseId = syncBaseId;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public java.util.Date getCreatedOn() {
        return createdOn;
    }

    public void setCreatedOn(java.util.Date createdOn) {
        this.createdOn = createdOn;
    }

    public String getDerivedEntityType() {
        return derivedEntityType;
    }

    public void setDerivedEntityType(String derivedEntityType) {
        this.derivedEntityType = derivedEntityType;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}