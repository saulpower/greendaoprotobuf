package com.saulpower.GreenWireTest.database;

import java.util.List;
import de.greenrobot.dao.DaoEnum;
import java.util.Map;
import java.util.HashMap;

import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table JOURNAL_ENTRY.
 */
public class JournalEntry extends SyncBase  {

    private String externalID;
    private String guid;
    private String name;
    private transient long journalEntriesGuardianId;
    private String tagString;
    private transient long journalEntriesStudentId;
    private MilestoneType milestoneType;
    private Long tenantID;
    private transient long saveResultSaveResultId;
    private String dateLastModified;
    private transient long journalEntriesPersonId;
    private transient Long syncBaseId;
    private Boolean isDeleted;
    private Integer version;
    private Boolean isPrivate;
    private Long id;
    private String dateCreated;
    private String notes;
    private JournalEntryType entryType;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient JournalEntryDao myDao;
    private SaveResult saveResult;
    private Long saveResult__resolvedKey;
    private List<Attachment> attachments;
    private List<Person> people;
    private List<JournalEntryComment> comments;
    private List<CustomValue> customValues;

    public JournalEntry() {
    }

    public JournalEntry(Long id) {
        this.id = id;
        setDerivedEntityType(getClass().getCanonicalName());
    }

    JournalEntry(String externalID, String guid, String name, long journalEntriesGuardianId, String tagString, long journalEntriesStudentId, MilestoneType milestoneType, Long tenantID, long saveResultSaveResultId, String dateLastModified, long journalEntriesPersonId, Long syncBaseId, Boolean isDeleted, Integer version, Boolean isPrivate, Long id, String dateCreated, String notes, JournalEntryType entryType) {
        this.externalID = externalID;
        this.guid = guid;
        this.name = name;
        this.journalEntriesGuardianId = journalEntriesGuardianId;
        this.tagString = tagString;
        this.journalEntriesStudentId = journalEntriesStudentId;
        this.milestoneType = milestoneType;
        this.tenantID = tenantID;
        this.saveResultSaveResultId = saveResultSaveResultId;
        this.dateLastModified = dateLastModified;
        this.journalEntriesPersonId = journalEntriesPersonId;
        this.syncBaseId = syncBaseId;
        this.isDeleted = isDeleted;
        this.version = version;
        this.isPrivate = isPrivate;
        this.id = id;
        this.dateCreated = dateCreated;
        this.notes = notes;
        this.entryType = entryType;
    }

    public JournalEntry(String externalID, String guid, String name, long journalEntriesGuardianId, String tagString, long journalEntriesStudentId, MilestoneType milestoneType, Long tenantID, long saveResultSaveResultId, String dateLastModified, long journalEntriesPersonId, Boolean isDeleted, Integer version, Boolean isPrivate, Long id, String dateCreated, String notes, JournalEntryType entryType) {
        this.externalID = externalID;
        this.guid = guid;
        this.name = name;
        this.journalEntriesGuardianId = journalEntriesGuardianId;
        this.tagString = tagString;
        this.journalEntriesStudentId = journalEntriesStudentId;
        this.milestoneType = milestoneType;
        this.tenantID = tenantID;
        this.saveResultSaveResultId = saveResultSaveResultId;
        this.dateLastModified = dateLastModified;
        this.journalEntriesPersonId = journalEntriesPersonId;
        this.isDeleted = isDeleted;
        this.version = version;
        this.isPrivate = isPrivate;
        this.id = id;
        this.dateCreated = dateCreated;
        this.notes = notes;
        this.entryType = entryType;
        setDerivedEntityType(getClass().getCanonicalName());
    }

    /** called by internal mechanisms, do not call yourself. */
    @Override
    public void __setDaoSession(DaoSession daoSession) {
        super.__setDaoSession(daoSession);
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getJournalEntryDao() : null;
    }

    public String getExternalID() {
        return externalID;
    }

    public void setExternalID(String externalID) {
        this.externalID = externalID;
    }

    public String getGuid() {
        return guid;
    }

    public void setGuid(String guid) {
        this.guid = guid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getJournalEntriesGuardianId() {
        return journalEntriesGuardianId;
    }

    public void setJournalEntriesGuardianId(long journalEntriesGuardianId) {
        this.journalEntriesGuardianId = journalEntriesGuardianId;
    }

    public String getTagString() {
        return tagString;
    }

    public void setTagString(String tagString) {
        this.tagString = tagString;
    }

    public long getJournalEntriesStudentId() {
        return journalEntriesStudentId;
    }

    public void setJournalEntriesStudentId(long journalEntriesStudentId) {
        this.journalEntriesStudentId = journalEntriesStudentId;
    }

    public MilestoneType getMilestoneType() {
        return milestoneType;
    }

    public void setMilestoneType(MilestoneType milestoneType) {
        this.milestoneType = milestoneType;
    }

    public Long getTenantID() {
        return tenantID;
    }

    public void setTenantID(Long tenantID) {
        this.tenantID = tenantID;
    }

    public long getSaveResultSaveResultId() {
        return saveResultSaveResultId;
    }

    public void setSaveResultSaveResultId(long saveResultSaveResultId) {
        this.saveResultSaveResultId = saveResultSaveResultId;
    }

    public String getDateLastModified() {
        return dateLastModified;
    }

    public void setDateLastModified(String dateLastModified) {
        this.dateLastModified = dateLastModified;
    }

    public long getJournalEntriesPersonId() {
        return journalEntriesPersonId;
    }

    public void setJournalEntriesPersonId(long journalEntriesPersonId) {
        this.journalEntriesPersonId = journalEntriesPersonId;
    }

    public Long getSyncBaseId() {
        return syncBaseId;
    }

    public void setSyncBaseId(Long syncBaseId) {
        this.syncBaseId = syncBaseId;
    }

    public Boolean getIsDeleted() {
        return isDeleted;
    }

    public void setIsDeleted(Boolean isDeleted) {
        this.isDeleted = isDeleted;
    }

    public Integer getVersion() {
        return version;
    }

    public void setVersion(Integer version) {
        this.version = version;
    }

    public Boolean getIsPrivate() {
        return isPrivate;
    }

    public void setIsPrivate(Boolean isPrivate) {
        this.isPrivate = isPrivate;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(String dateCreated) {
        this.dateCreated = dateCreated;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public JournalEntryType getEntryType() {
        return entryType;
    }

    public void setEntryType(JournalEntryType entryType) {
        this.entryType = entryType;
    }

    public enum JournalEntryType implements DaoEnum {
        GENERAL(0),
        CLASSWORK(1),
        INCIDENT(2),
        MEAL(3),
        PLAY(4),
        BATHROOM(5),
        MILESTONE(6);

        private static final Map<Long, JournalEntryType> intToTypeMap = new HashMap<Long, JournalEntryType>();

        static {
            for (JournalEntryType type : JournalEntryType.values()) {
                intToTypeMap.put(type.value, type);
            }
        }

        public static JournalEntryType fromInt(long i) {
            JournalEntryType type = intToTypeMap.get(Long.valueOf(i));
            return type;
        }

        private final long value;

        private JournalEntryType(long value) {
            this.value = value;
        }

        @Override
        public long getValue() {
            return value;
        }
    }

    public enum MilestoneType implements DaoEnum {
        TALK(0),
        ROLLOVER(1),
        SITUP(2),
        SPEAK(3),
        BATHROOM(4);

        private static final Map<Long, MilestoneType> intToTypeMap = new HashMap<Long, MilestoneType>();

        static {
            for (MilestoneType type : MilestoneType.values()) {
                intToTypeMap.put(type.value, type);
            }
        }

        public static MilestoneType fromInt(long i) {
            MilestoneType type = intToTypeMap.get(Long.valueOf(i));
            return type;
        }

        private final long value;

        private MilestoneType(long value) {
            this.value = value;
        }

        @Override
        public long getValue() {
            return value;
        }
    }

    /** To-one relationship, resolved on first access. */
    public SaveResult getSaveResult() {
        long __key = this.saveResultSaveResultId;
        if (saveResult__resolvedKey == null || !saveResult__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SaveResultDao targetDao = daoSession.getSaveResultDao();
            SaveResult saveResultNew = targetDao.load(__key);
            synchronized (this) {
                saveResult = saveResultNew;
            	saveResult__resolvedKey = __key;
            }
        }
        return saveResult;
    }

    public void setSaveResult(SaveResult saveResult) {
        if (saveResult == null) {
            throw new DaoException("To-one property 'saveResultSaveResultId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.saveResult = saveResult;
            saveResultSaveResultId = saveResult.getId();
            saveResult__resolvedKey = saveResultSaveResultId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Attachment> getAttachments() {
        if (attachments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AttachmentDao targetDao = daoSession.getAttachmentDao();
            List<Attachment> attachmentsNew = targetDao._queryJournalEntry_Attachments(id);
            synchronized (this) {
                if(attachments == null) {
                    attachments = attachmentsNew;
                }
            }
        }
        return attachments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAttachments() {
        attachments = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Person> getPeople() {
        if (people == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PersonDao targetDao = daoSession.getPersonDao();
            List<Person> peopleNew = targetDao._queryJournalEntry_People(id);
            synchronized (this) {
                if(people == null) {
                    people = peopleNew;
                }
            }
        }
        return people;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetPeople() {
        people = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<JournalEntryComment> getComments() {
        if (comments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            JournalEntryCommentDao targetDao = daoSession.getJournalEntryCommentDao();
            List<JournalEntryComment> commentsNew = targetDao._queryJournalEntry_Comments(id);
            synchronized (this) {
                if(comments == null) {
                    comments = commentsNew;
                }
            }
        }
        return comments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetComments() {
        comments = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<CustomValue> getCustomValues() {
        if (customValues == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CustomValueDao targetDao = daoSession.getCustomValueDao();
            List<CustomValue> customValuesNew = targetDao._queryJournalEntry_CustomValues(id);
            synchronized (this) {
                if(customValues == null) {
                    customValues = customValuesNew;
                }
            }
        }
        return customValues;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetCustomValues() {
        customValues = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}